---
title: "Architecture"
description: "Four-service architecture designed for governance, not just convenience"
---

SAGE is split across four independent Vercel deployments. This isn't a microservices fetish — it's a governance decision. Each service has a clear, defensible answer to two questions any IT review will ask:

1. **What data does the AI have access to?**
2. **What happens if it breaks?**

## System diagram

![SAGE architecture — sage-knowledge feeds sage-web, which connects to sage-gov, sage-gis, and sage-map](/images/architecture-overview.png)

## Service boundaries

<AccordionGroup>
  <Accordion title="sage-web — Chat UI + AI orchestration">
    **What it does:** Hosts the chat interface, manages conversations, orchestrates AI tool calls, handles map screenshots, optimizes token budgets. Bundles domain knowledge from sage-knowledge and exposes it via `load_skill`.

    **What it accesses:** Only what sage-gov and sage-gis return via MCP, plus bundled read-only skill files from sage-knowledge. Cannot query databases or GIS services directly. This is the governance surface — authentication, moderation, audit logging, disclaimers, and rate limiting live here.

    **If it breaks:** No chat. sage-gov and sage-gis continue serving data to any other MCP client. sage-map continues as a standalone map viewer.
  </Accordion>

  <Accordion title="sage-knowledge — Domain knowledge base">
    **What it does:** Contains curated domain expertise across 10 skill areas — property research workflows, zoning interpretation, hazard analysis patterns, budget navigation, and more. Content is bundled into sage-web at build time and loaded progressively via the `load_skill` tool.

    **What it accesses:** Nothing. This is a static content repository with no runtime, no API, and no external access. It's a build-time dependency of sage-web only.

    **If it breaks:** AI still functions but loses domain-specific guidance. Tool calls work; interpretation quality degrades. The `<available_knowledge>` block disappears from the system prompt, and `load_skill` returns nulls.
  </Accordion>

  <Accordion title="sage-gov — Public records MCP server">
    **What it does:** Searches and retrieves public government documents — budget, county code, General Plan, organizational chart, Board of Supervisors meeting minutes.

    **What it accesses:** Static JSON and SQLite files bundled at deploy time. All data is already public. No external API calls. No write access to anything.

    **If it breaks:** Property research, map tools, and spatial queries continue working. Only budget/code/plan questions are affected.
  </Accordion>

  <Accordion title="sage-gis — Spatial/GIS MCP server">
    **What it does:** Queries ArcGIS REST services for parcels, zoning, hazards, elevation, directions, and map rendering. Generates static map images and infographics.

    **What it accesses:** Public ArcGIS FeatureServer and MapServer endpoints — the same services that power the county's existing public parcel viewer. Read-only. Cannot modify any GIS data.

    **If it breaks:** Budget, code, and plan queries continue working. Map rendering and property lookups are affected.
  </Accordion>

  <Accordion title="sage-map — Interactive ArcGIS map">
    **What it does:** Renders an interactive ArcGIS web map embedded as an iframe. Accepts commands (pan, zoom, highlight parcels/features, toggle layers) and returns screenshots for AI vision.

    **What it accesses:** ArcGIS Online web maps via the standard Maps SDK. Same data as any ArcGIS web application. No MCP tools. No AI. Pure visualization.

    **If it breaks:** Chat and all tool queries continue working. Users lose the interactive map but still get inline map images from sage-gis.
  </Accordion>
</AccordionGroup>

## Data flow

### User asks a question

```
1. User types "Tell me about 123 Main St, Fairfield"
2. sage-web captures map screenshot + map state (center, zoom, layers)
3. sage-web sends message + screenshot to Claude Opus 4.6
4. Claude decides to call geocode_address → get_parcel_details → get_zoning → get_flood_zone → show_map
5. Each tool call → MCP HTTP request to sage-gis
6. sage-gis queries ArcGIS REST → returns structured data
7. Claude synthesizes results into a natural language response
8. Response streams back to the browser with inline map and data
```

### AI controls the map

```
1. Claude calls update_map({ highlight_apns: ["003-025-102"], zoom: 17 })
2. sage-web posts command to sage-map iframe via postMessage
3. sage-web waits for command-ack (up to 8 seconds)
4. sage-map executes: highlights parcel, zooms in, waits for render
5. sage-map captures 1092×1092 screenshot
6. sage-map sends command-ack with screenshot back via postMessage
7. sage-web reports ackStatus to AI ("confirmed" / "unconfirmed" / "failed")
8. sage-web attaches screenshot to next AI context
9. Claude can now describe what it sees on the map
```

The ack-before-output pattern prevents hallucination: if the iframe bridge is broken (origin mismatch, deployment protection, iframe not loaded), the AI gets `ackStatus: "unconfirmed"` and tells the user honestly instead of fabricating a map description. See [Map Protocol](/integration/map-protocol) for the full contract.

Beyond parcel highlights, `update_map` supports **feature highlighting by WHERE expression** — e.g., `highlight_features: { layer_title: "FHSZ", where: "HAZ_CLASS = 'Very High'" }` highlights all severe fire hazard zones with orange outlines.

## Why four services instead of one

| Concern | Monolith | Four services |
|---------|----------|---------------|
| **Security review** | "The AI can access everything" | Each service has an explicit, bounded data scope |
| **Failure blast radius** | Everything goes down together | Services fail independently |
| **Deployment** | One change redeploys everything | Deploy only what changed |
| **Access control** | One permission model | Each service can have different auth |
| **Compliance** | Hard to audit | Each service has a clear data inventory |
| **Scaling** | Scale everything or nothing | Scale hot services independently |

## Observability

Every sage-web interaction is instrumented end-to-end and persisted to Vercel Blob storage. This gives full visibility into what happened during any conversation — tool chains, timing, token usage, errors, and the AI's final response.

### What gets logged

Each interaction produces a single JSON record containing timestamped events:

| Event | When | Key data |
|-------|------|----------|
| `request` | API entry | Message count, model, map state, user message text |
| `mcp.connect` | MCP ready | Tool count, connection time |
| `step` | Each AI step | Tool calls (name + args), tool results, token usage |
| `screenshot.inject` | Screenshot → AI | Mode, media type, size |
| `stream.finish` | Response done | Duration, total steps, all tool calls, full usage breakdown, AI response text |
| `error` | Any failure | Error message, phase (pre-stream or stream) |

### How it works

```
User sends message
  → InteractionCollector created with UUID
  → Each lifecycle event logged via prodLog() → console.log + collector buffer
  → On completion: collector.flush() writes full record to Vercel Blob
  → Response includes X-Sage-Interaction-Id header for correlation
```

Records are stored at `interactions/{YYYY-MM-DD}/{uuid}.json` in Vercel Blob. An authenticated API endpoint (`/api/logs`) provides list, detail, search, and purge operations. A CLI script (`scripts/sage-logs.sh`) wraps the API for terminal use.

### Querying interactions

```bash
# CLI (from sage-web repo root)
./scripts/sage-logs.sh                     # list today's interactions
./scripts/sage-logs.sh --latest            # most recent interaction detail
./scripts/sage-logs.sh --summary           # one-line-per-interaction table
./scripts/sage-logs.sh --id <uuid>         # full record with events
./scripts/sage-logs.sh --search "error"    # full-text search
```

The API is also queryable programmatically via `GET /api/logs?date=YYYY-MM-DD&id=<uuid>` with Bearer token auth — independent of Vercel deployment protection.

### Design decisions

- **Dual output**: `prodLog()` writes to both console.log (Vercel runtime logs for real-time tailing) and the collector (Blob persistence for historical queries)
- **Full verbosity**: Tool args, tool results, AI response — all captured. This is an internal county app, not public SaaS. Vercel logs are behind auth.
- **Size management**: String values capped at 4KB, base64 data stripped, to prevent oversized records
- **Fire-and-forget persistence**: Blob write failure doesn't break the response — it logs to console and moves on
- **No external deps**: Uses `@vercel/blob` (already in the Vercel ecosystem) and `crypto.randomUUID()` (built-in)

## Deployment

All four services deploy to Vercel via GitHub push-to-deploy:

| Service | Repository | URL | Runtime |
|---------|-----------|-----|---------|
| sage-web | `solano-gis/sage-web` | [sage-web-sand.vercel.app](https://sage-web-sand.vercel.app) | Vercel |
| sage-gis | `solano-gis/sage-gis` | `sage-gis.vercel.app/api/mcp` | Vercel |
| sage-gov | `solano-gis/sage-gov` | `sage-gov.vercel.app/api/mcp` | Vercel |
| sage-map | `solano-gis/sage-map` | `sage-map.vercel.app` | Vercel |
| sage-knowledge | `solano-gis/sage-knowledge` | (none — build dependency) | Static |

Each repo has its own `CLAUDE.md` with service-specific development context. sage-knowledge has no deployment — its content is copied into sage-web's `data/skills/` directory during the build sync process.
