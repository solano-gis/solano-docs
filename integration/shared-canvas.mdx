---
title: "The Shared Canvas"
description: "How AI and user draw on the same live map"
---

The AI and user share a single live ArcGIS map — same pixels, same layers, same state. Neither has a private view.

## The core idea

The AI commands the same map the user sees via an iframe postMessage bridge. After every command, the map captures a screenshot and sends it back — the AI's "eyes."

```
┌─────────────────────────────────────────────────────────┐
│  sage-web (chat UI)                                     │
│                                                         │
│   User message ──→ AI draws ──→                         │
│   postMessage('annotate', polygons) ──────────────→     │
│                                                    │    │
│   ┌───────────────────────────────────────────┐    │    │
│   │  sage-map (iframe)                        │◄───┘    │
│   │                                           │         │
│   │   Renders on GraphicsLayer                │         │
│   │   Captures screenshot (1092×1092 JPEG)    │         │
│   │   Sends command-ack + screenshotDataUrl ──────→     │
│   └───────────────────────────────────────────┘         │
│                                                         │
│   AI receives screenshot ──→ describes what it sees     │
└─────────────────────────────────────────────────────────┘
```

The AI draws, sees the result, and can adjust. The user watches in real time.

## Two drawing systems, one map

| | AI annotations | User freehand |
|---|---|---|
| **Triggered by** | `annotate_map` tool call | Pencil button |
| **Shapes** | Markers, lines, polygons, circles, labels | Freehand polylines |
| **Color** | 6-color palette (no orange) | Orange (SAGE brand) |
| **Style** | Hand-drawn jitter | Smooth strokes |
| **Persistence** | AI-managed (clear/replace by group) | User clears manually |
| **Layer** | Annotation GraphicsLayer | Sketch GraphicsLayer |
| **AI awareness** | Full (AI drew it) | Via stroke summaries + screenshot |

Orange is reserved for user actions (drawing, selection, highlights). The AI palette excludes it, so who drew what is always clear.

## AI annotations

### Color palette

Six constrained colors — no arbitrary hex. Avoids clashing with the orange highlight system.

| Color | Hex | Typical use |
|-------|-----|-------------|
| `crimson` | `#DC2626` | Boundaries, danger, warnings |
| `emerald` | `#059669` | Natural areas, parks |
| `cobalt` | `#2563EB` | Water, infrastructure (default) |
| `violet` | `#7C3AED` | Special or unique features |
| `teal` | `#0D9488` | Alternative to green |
| `slate` | `#475569` | Subtle reference lines |

### Fill behavior

Polygons and circles are **outline-only by default**. `filled: true` adds area shading at 18% opacity.

### Hand-drawn jitter

AI geometry is mathematically perfect — misleadingly authoritative for boundaries drawn from memory. The renderer post-processes with:

1. **Subdivide** — split edges into ~20px segments (5-corner polygon → 50+ points)
2. **Jitter** — offset each intermediate point by ±4 pixels, scaled to map resolution

Seeded PRNG ensures deterministic wobble (no flicker on re-render). First/last vertices stay exact so polygons close cleanly.

<Note>
Jitter applies only to AI annotations. User freehand strokes render as-is. Data-layer highlights use exact GIS geometry.
</Note>

### Annotation groups

Each `annotate` call accepts a `groupId` for independent management:

```
annotate_map({ id: "flood-zones", annotations: [...] })    // Draw flood zones
annotate_map({ id: "fire-zones", annotations: [...] })     // Add fire zones
annotate_map({ id: "flood-zones", annotations: [...] })    // Replace flood zones only
```

## User freehand drawing

Pencil button (embed mode) activates freehand polyline drawing — circle areas, point at features, sketch boundaries, then ask.

### Draw-to-ask workflow

```
1. User clicks pencil → draw mode active (button turns orange)
2. User draws freehand strokes
3. Each stroke fires 'stroke-added' (lightweight, no screenshot)
4. Stroke count + clear button shown above chat input
5. User types question and sends
6. sage-web requests 'get-sketch-summary' → per-stroke bbox + screenshot
7. Summaries + screenshot injected into AI context
8. AI reasons using both geometry and vision
```

### Per-stroke summaries

```
StrokeSummary {
  bbox: { north, south, east, west }
  centroid: { latitude, longitude }
}
```

Bounding boxes give the AI coarse location; the screenshot provides visual context. Raw polyline vertices are not sent.

### Persistence

User drawings persist until explicitly cleared. The user may draw across multiple messages, building up context the AI reasons about cumulatively.

## Visual layer stack

| Layer | Contents | Controller | Color |
|-------|----------|-----------|-------|
| ArcGIS data | Parcels, zoning, aerials, hazards | AI + user | Layer symbology |
| Highlights | Parcels by APN, features by WHERE | AI | Orange |
| Annotations | AI-drawn shapes and labels | AI | 6-color palette + jitter |
| Sketch | User freehand strokes | User | Orange |

A user can immediately distinguish:
- **Crisp orange outlines** = real GIS data the AI queried
- **Wobbly colored lines** = AI sketching from approximate knowledge
- **Smooth orange freehand** = user-drawn

## Why this matters

**No divergence** — both parties see the same visual truth. When the AI says "I've outlined the marsh in green," the user sees that exact outline.

**AI self-correction** — the AI receives screenshots of its own drawings and can acknowledge gaps or offer to redraw.

**Visual honesty** — wobbly jitter communicates that AI geometry is approximate, not survey-grade. Actual GIS data renders with exact geometry, visually distinct.

## See also

- [Map Protocol](/integration/map-protocol) — command/event registry, annotation payloads
- [sage-map](/services/sage-map) — rendering, palette, file structure
- [sage-web](/services/sage-web) — tool schema, context injection
